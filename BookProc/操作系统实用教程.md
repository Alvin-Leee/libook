### 整体流程

---

- 操作系统历史背景及框架
- OS接口（Shell）
- 进程与并发
- 存储管理
- O/I系统
- 文件系统
- 磁盘管理
- 系统安全





### 主要问题

---

- 计算机的发展过程
- 电子管与晶体管的区别（https://www.zhihu.com/question/21125940）
- 为什么叫晶体管
- 冯诺依曼计算机的组成及程序的存储执行方式
- 第一代高级语言出现在第几代计算机上
- 网络的雏形出现在第几代计算机上
- 什么是云计算，“云”是什么



- 第一代计算机的运行过程和操作流程
- 为什么出现批处理（面向作业）
- 什么是联机批处理，执行过程是什么，还存在什么问题
  - 先读作业说明书，满足则调入内存，再从外存上读取编译程序
- 什么是脱机批处理，解决什么问题，卫星机是什么
- 批处理后还存在的问题是什么（人工装填）



- 通道是什么，与CPU的关系是什么
- 中断是什么，主要流程是什么
- 执行系统是什么，最初是用来干什么的



- 什么多道程序，为什么会出现多道程序（面向程序）
- 什么是并发执行（一段时间内）
- 多道批处理系统的执行过程



- 分时系统出现的原因，联机工作方式
- CPU如何处理分时系统
- 实时（及时）操作系统出现的原因，与分时系统（时间片）有关系吗



- 摩尔定律是什么



- 目前微型计算机（PC）上的操作系统有什么

- DOS操作系统的全称是什么（Disk Operation System磁盘操作系统）
- Windows操作系统提供GUI，全称是什么（Graphic user interface 图形用户界面）
- Linux的前身是什么（Minix），基础是什么（Unix）
- Linux的内核有几种（稳定版和开发版），版本号的规律是什么（看版本号第二位的奇偶）
- Linux分类
  - debian: Ubuntu / redhat: Centos/ Arch Linux



- GPL许可证是什么
  - general public license 通用公用许可证
- Copyleft和Copyright的区别
  - Copyleft无线复制和修改
  - Copyright有独占权
- GNU计划是什么，含义是什么
  - GNUS NOT UNIX的缩略词
  - GNU是一个操作系统，完全自由，所以说不是Unix，但从技术上是类似Unix



- 人在解决科学问题时，首先要分析研究的对象，给出问题的定义和求解方法
- 问题的形式化定义叫做什么（数学模型）
- 问题求解方法的形式描述叫什么（算法）



- 裸机是什么，如何运行
  - 只有硬件，只能处理机器语言
- 软件包括什么
  - 系统软件主要有什么（OS，编译程序）
  - 应用软件、工具软件（引导，诊断等）

- 操作系统的主要作用（3个）
  - 系统软件，管理系统资源（向下的作用）
  - 提供用户接口（向上的作用）
  - 中间的作用

- 操作系统的管理类型
  - 处理机管理
  - 存储器管理
  - 外设管理（I/O设备管理、磁盘管理）
  - 文件管理（包括进程管理）
- 设备无关性指什么P25
- 并发和共享的关系



- 独立运行最小的实体是什么
- 进程存在的标志是什么
- 进程控制块信息（标识、状态、调度、链、时间片、通信、资源）
- 虚拟机的构成



- CPU包含什么
  - PC/ IR/ R/ MAR/ MDR/ ALU/ CU/ IO AR/ IO DR

- 处理机模式
  - 管态和目态，状态的转化使用什么（中断）
  - 特权指令和非特权指令
- IO指令（系统调用）是特权指令还是非特权指令



- 操作系统与应用程序之间的接口是什么
- 大部分的系统调用在libc库中，通过C函数调用可以调用这些系统调用
- 系统调用的实现是通过什么（中断）
- 中断向量号是多少，十六进制如何表示（128, $0x80）
- 中断的执行过程：将系统调用的参数加到CPU寄存器中，执行“int $0x80”指令，运行系统调用，并将系统调用的返回值送入CPU的寄存器中，标准库程序取得该返回值，送回用户指令



- shell命令有内部命令和外部命令吗P60
  - 先看是不是内部命令，再看是不是应用程序，否则返回出错

- shell的命令行提示符对于普通用户是什么，对于root用户是什么



- 硬盘重新分区要清空所有数据吗（会）
- 一个硬盘最多能建立几个主分区（4）

- 操作系统需要安装在什么分区上（主）
  - 一个硬盘最多安装4个操作系统
- 文件系统和交换空间（虚拟内存）都需要各自占据硬盘上的一个独立分区



- Linux文件系统的结构是什么结构（树形）
- 用户的主目录是/home/xxx
- 各用户的路径在哪个文件里 /etc/passwd
- 文件的权限意义 x-xxx-xxx-xxx n user group
  - 第一位是文件类型
  - 所有者、所属用户组、其他用户
  - 第二列是链接数
  - 第三列是所有者
  - 第四列是用户组

- ln是什么命令
- 修改一个链接文件后，另一个副本是否会发生改变
  - 是，他们是指向同一个位置的，只有当所有文件都被删除，最后文件才会被删除



- 前台进程可以交互吗
- 从shell提示符下输入的命令式前台进程还是后台进程P90
- 要想使shell输入后台进程运行，需要如何操作
- 进程是否有优先级，超级用户和普通用户比较，前台进程和后台进程比较P92
- 可以降低自己的优先级吗，哪个用户可以降低
- 哪个用户可以增加自己的优先级，使用什么命令来修改优先级



- 影子口令是什么(能够穷举/etc/passwd中明文破解口令，则将加密的口令移到/etc/shadow文件中，只有root可读，/etc/passwd密文显示一个x)
- 使用什么加密算法来加密口令（DES）
- 该加密算法是可逆的吗(No)
- /etc/passwd文件是全局可读的吗（yes），算法是公开的吗（yes）



- ext2/ ext3/ FAT32/ FAT16的区别
  - 前两个是专门为linux设计的文件系统，后两个是Windows下的文件系统，ext3比ext2多了日志管理
  - LInux还支持NFS (Network file system)

- Linux下设备以什么方式进行管理（文件系统）



- 同时在不同的CPU上执行是并行还是并发
- 一个时间段内，分时运行在同一个CPU上是并行还是并发
- 作业是什么（未进入内存），进程是什么（进入内存）
- 处理机管理两个阶段是什么P106
- 低级调度是指什么的调度，为什么称其为低级调度（直接实行处理机时间分配）
- 高级调度指什么的调度
- 作业进入内存之前的调度由谁决定
- 进程的七状态模型（创建、就绪、就绪挂起、阻塞、阻塞挂起、运行、终止）
- 挂起的含义和意义
- 阻塞状态被挂起后成为什么状态（阻塞挂起），被挂起的原因是什么（为其他就绪态让内存）
- 运行状态被挂起的原因（用户程序主动），挂起后什么状态（就绪挂起）
- 就绪状态被挂起的原因（为运行态让内存）
- 就绪挂起到就绪态的原因（内存中没有就绪态进程了）
- 阻塞挂起到就绪挂起的原因（I/O已被分配）
- 创建态会到就绪挂起态吗（会，内存不够了）



- 单道程序的运行过程（首先放入内存，其次将程序地址放入PC中）
- 多个程序在内存中顺序执行（先放第一个PC，执行完后，再放第二个，以此类推）
- 多个程序并发执行（先运行第一个，固定时间后，轮流给下一个，需要保存中断现场）
- 中断现场包括什么（断点地址，程序状态字、通用寄存器、堆栈和当前状态（就绪还是阻塞））
- 使用什么来保存中断现场（PCB）
- 进程的构成P108



- 进程调度中，系统进程和用户进程的优先度谁大
- 进程控制中，是否允许一个进程创建和控制另一个进程，创建其他的进程被称为什么？被创建的进程被称为什么？P115
- 原语的定义（实现某个特定的操作，不能被中断）

- 原语运行在管态还是目态？
- 原语是否常驻内存？进程是如何使用原语的（系统调用）
- 原语的执行方式是什么（关中断）



- 进程控制原语
  - 创建原语的过程（创建PCB，写入状态，将程序调入内存，把PCB挂在链上）
  - 撤销原语的过程（撤销PCB，释放使用的资源，是否释放程序段？）
  - 阻塞原语的过程（中断处理机，停止进程运行，设置阻塞，插入等待队列）
  - 唤醒原语的过程（改为就绪态，进入就绪队列）



- 线程引入的作用（解决进程切换付出的时空开销大的问题，因为进程切换需要保存进程的状态，费空间，CPU要进行处理，费时间）
- 引入线程后，进程是什么的基本单位，线程是什么的基本单位
- 线程有什么资源（程序计数器、寄存器和栈）
- 同一进程中的多个线程之间可以并发执行吗P117
- 线程的几种基本状态（就绪、阻塞、执行）
- 同一进程中的线程进行切换会引起进程的切换吗
- 不同进程中的线程进行切换会引起进程的切换吗
- 进程切换的开销和线程切换的开销谁大（线程切换只需有少数寄存器的改变，不会涉及存储器管理方面的操作）



- 进程调度算法的过程

  - 先来先服务（FCFS），是否会饥饿
  - 简单轮转调度（队列+时间片），是否会饥饿
  - 分级轮转调度（多个具有优先级的队列+时间片），当前一个队列执行完再执行下一个队列
  - 抢占式和非抢占式优先级法
    - 系统进程和用户进程优先级比较
    - I/O繁忙型进程和CPU繁忙型进程（前者）
    - 前台用户进程和后台用户进程比较P121
    - 联机用户进程和脱机用户进程

  - 动态优先级法（运行时间、等待时间）

    

- 临界资源定义P123
- 使用什么方式实现进程对临界资源的同步与互斥（信号量、PV操作）
- 进程的互斥使用互斥信号量(mutex)
- 进程的同步使用私用信号量
- 描述生产者和消费者模型的执行过程P127
- 描述读者和写者模型的执行过程（任一写者与其他读者或写者互斥访问）

- 管程的概念（分散的各同类临界区集中，为每个共享资源设立一个专门的管程来统一管理各进程对资源的访问）
- 建立管程的原因（对临界区的执行分散，不利于系统对临界资源的控制和管理）
- 访问共享资源，就必须通过相应的管程进入
- 访问互斥资源，管程每次只允许一个进程进入其内



- 进程通过什么方式进行通信P131
  - 每个进程都要设置一个消息队列



- 死锁的原因（一直分配不到需要的资源）
- 预防死锁
  - 资源独占的概念（运行前必须要获得所有的资源）
  - 银行家算法是什么？过程是什么？
- 发现死锁的方法：使用进程-资源图，当且仅当S状态的进程资源图是不可完全简化的
- 解除死锁的方法
  - 资源剥夺法：建立检查点，还原算法，从一些进程强行剥夺足够数量的资源
  - 撤销进程法：逐渐撤销已死锁的进程，直到获得解除死锁所需要的资源



- Linux中使用什么数据结构标志进程的存在P141
- task数组保存的是什么(Linux中task就是进程)
- task数组大小默认为512，表明什么？



- 系统启动时，运行启动程序，只有一个进程运行，该进程叫什么
- 系统初始化结束后，初始进程启动一个内核线程（init）后变为什么状态（init程序创建新的进程后，这些新的进程能够再次创建新的进程）
- 调度程序什么时候会运行空闲进程？
- 新的进程建立过程（创建tast_strcut结构，复制父进程的tast_struct结构，修改部分数据，分配新的核心堆栈页，分配新的pid，填入到task数组中，插入运行队列）
- 进程创建时，内核为子进程分配物理内存吗？（不会，让父进程与子进程以只读方式共享父进程原分配的内存）



- 线程的分类是什么（用户线程、内核线程）
- 什么是用户线程（不需要内核支持），线程的调度由谁完成
- 内核线程由谁完成线程的调度
- 两个系统调用可以建立新的进程
  - fork的作用
  - clone的作用
- 内核程序使用的kernel_thread是通过哪种系统调用创建的内核进程



- 信号是什么（进程间通信机制之一，发送异步信号，比如外设中断、浮点运算溢出、内存访问错误等）
- 内核用一个字来代表所有的信号，那么信号种类的最多数目是多少？（32位的字，有32种信号）
- 发送给进程的信号会立即得到处理吗？等到什么时候处理该信号



- 管道是什么（最常用的进程间通信IPC机制（Inter-Process Communication））
  - 如果没有管道机制，使用文件传递大量数据时，造成许多空间和时间上的浪费
  - 利用管道，可以使一个进程的输出成为另一个进程的输入
- Linux中如何实现管道的，大概意思即可（两个file结构指向同一个临时VFS节点，两个VFS索引节点指向同一个物理页）P151
- VFS什么意思（虚拟文件系统）



- 简要描述鼠标双击图标，应用程序运行起来的过程

  （首先第一次点击图标，产生中断，OS进行中断处理，通过分析程序获取图标在桌面的坐标得知是哪个程序）

  （第二次点击图标，OS进程管理模块为程序建立进程，调用存储管理模块为程序分配内存，调用文件管理系统提供在外存上的位置，再由设备管理模块启动磁盘驱动，将程序从磁盘读入内存）

- 计算机体系结构从以xx为中心到以xx为中心



- 一般内存被分成若干个区域，至少也要分成两个区域，分别是什么（系统软件、用户程序）



- 描述程序是如何变为内存中的可执行代码的

  （源代码汇编或编译，优化并连接后生成目标代码（相对地址），然后进行地址重定位放入内存中）

- 静态重定位和动态重定位的区别P166
- 动态重定位的优势
- 多个进程可以共享的内容有（代码和数据）
- 内存的扩充指的是什么（使用硬件和软件相互协作，虚拟存储管理技术）
- 为了支持多个程序并发执行，引入了什么管理技术（分区式）
- 每个分区能够存储几个程序，程序能够在其他程序主流的分区中运行吗
- 分区管理会带来碎片的问题，试说明内部碎片和外部碎片都是什么
- 固定式分区和可变式分区的概念
- 固定式分区应该采用什么方式来记录分区状态
- 可变分区的分配算法的过程P169
  - 最佳适应算法（容量最小，使碎片减小）
  - 最先适应算法
  - 最坏适应算法（容量最大，使少碎片）
  - 下次适应算法（空闲区形成链）
- 记录内存分配的表，一般由两张，请分别说明他们的作用（P表，记录已分配的分区，F表，记录空闲的分区）

- 空闲分区表的表项排序方式与分配算法有关系吗？请详细说明P169

- 空间释放时对于上下都有空闲区，应该怎么处理

- 移动技术是干什么的，主要作用是什么（空闲集中）

- 分区管理的保护若使用界地址法，可以采用什么寄存器？

  （上、下界寄存器 或者基址（当定位使用）、限长寄存器）



- 页式存储管理的思想（存放到不连续的内存区域中）
- 在内存中原先是由字节（或字）编址，若将内存等分成大小固定的若干块，那么地址编号就不是字节（或字），而是以页号进行编址，则该编号被称作什么（物理块号）
- 若将每个用户程序的虚地址空间也划分为同样大小的若干页面，每个页面也对应一个编号，则该编号被称作什么（就叫做页号）
- 若被分页后，那么用户的地址组成变成了什么（相对页号和页内地址）
- 若用户想要访问内存，系统会如何处理用户地址（将用户的相对地址改为物理块号，页内地址不变）
- 页式存储管理需要的软件和硬件分别是什么（页表和地址转换机构、页表始址寄存器、页表长度寄存器、高速寄存器）
- 页表存放在进程的哪里（PCB中）
- 页表中存放的是什么（逻辑地址中的页号和物理块号的对应关系）
- 每执行一条指令时按照逻辑地址中的页号查页表，如果页表中没有页号，产生一个什么事件（缺页中断）
- 多级页表（页目录表+页表+页内偏移）

- 若不使用快表，一级页表的情况下，需要几次访问内存（2次，先读页表，再取数据）

- 快表的作用（用来存放当前访问最频繁的少数活动页的页号）

- 快表中访问位的作用（淘汰作用）

- 快表中特征位的作用（表示该行有数据）

- 在具有快表的存储系统中，描述一下地址转换的过程

  （得到页号，同时在快表和页表中进行查找，若快表中没有，则将页表放到快表的空闲项中，没有空闲就替换最早的）

- 页式存储管理的缺点是什么（页面大小是固定的，程序长短不一，所以每个程序的最后一页总有一部分空间利用不到，调取一页时，可能没有调取到完整的程序）



- 段式存储管理中作业的地址组成是什么（若干逻辑分段，每个分段有自己的名称，对于一个分段，是一个连续的地址区）

- 在内存中，每个分段占一个分区

- 段式存储的地址结构（逻辑地址： 段号+段内位移）

- 段表项包含什么（段号，段长，段的基址，逻辑地址的段号就是段表项的段号）

- 请简述段表转换的流程（在段表中查找段号，比较段内地址和段长，内存地址=段基址+段内地址）

  

- 段页式存储管理下用户逻辑地址的组成是什么（段号+段内页号+页内地址）

- 段页式存储管理下地址转化的流程（段表寄存器保存的是段表大小和段表地址，根据段表地址和段号得到页表地址，根据段内页号读取页表，获取物理页号，再加上块内地址得到内存地址）

- 段页号需要几次访问内存

  

- 覆盖与交换技术是在哪两个存储空间进行交换（磁盘和内存）

- 通常和单一连续区、固定分区和可变分区技术配合使用

- 覆盖技术实现的过程（将程序分段，逻辑上不会同时执行的分开，暂时没有执行的放在磁盘上，等执行完某段之后将没有执行的移到内存中执行）

- 交换技术实现的过程（把作业装入内存后，可以把它移出内存，一般有地址重定位，作业换入内存时不一定要装入它被换出前所占据的区域）

- 局部性原理是什么（时间局部性和空间局部性）P184

- 简述虚拟存储技术的执行过程（不必全部读入内存，只需将当前需要执行的段或页导入内存，先开始执行，如果缺页再去磁盘中取）

- "颠簸"或“抖动”是什么意思（过度的页面调度）

- 工作集的概念（最近被访问过的页面集合）

- 一个进程的工作集会经常变化吗？（不会，因为局部性原理）

- 虚拟页式存储管理的思想是什么？

- 使用虚拟页式存储管理时需要在页表中添加哪些项呢（驻留位，内存块号，外存地址，访问位，修改位）

  - 驻留位也叫中断位，表示该页在内存还是外存中
  - 修改位和访问位是页面置换算法需要的

- 如果发生缺页中断，那么重新执行的过程是什么（首先查内存，不存在就往磁盘中查找，有空白页就直接放入，没有空白页就使用页面置换算法淘汰一个页面，修改过就写入外存，未修改过就不动）

- 缺页中断处理要哪些问题（请求I/O时，会涉及到将当前进程阻塞的进程调度；调取页面时，会涉及到设备管理和文件系统管理等）

- 调页策略有哪些？（请求调页（只调当前页，会有大量IO），预调页（根据局部性原理，调取该页与相邻的几页））

- 置换策略有哪些？

  - 固定分配全局置换（根据进程类型，为进程分配固定页数的内存空间，缺页时在自己的空间内进行置换）
  - 可变分配全局置换（预先分配物理块，不够时从OS的空闲队列中取物理块，OS的空闲物理块用完时再调取新页面）
  - 可变分配局部置换（预先分配物理块，缺页时只从它自己的物理块中置换，若频繁发生缺页中断，再给它分配一些新的物理块）



- 页面置换算法

  - FIFO

  - LRU（Least Recently Used）最少最近使用

    - 思想：过去一段时间里不被访问过的页，最近的将来可能也不会再被访问
    - 设置一个t，相对当前时间最大的t
    - 或设置一个标志位，调入时初始为0，其它+1，淘汰标志位最大的页

  - LFU（Least Frequently Used）最不频繁使用

    - 计数器+1，淘汰最小的页

  - 巧记LRU 和 LFU : 最近的清零，频繁的+1，Least是修饰词，表否定，清零的淘汰最大的，加1的淘汰最小的

  - OPT 最优算法：预测未来，把最长时间后才用到的替换出来

  - 命名空间的作用（避免变量命名重复，比如namespace std，就是使用标准库的命名空间，自己写变量名的时候不能与里面的命名重复）

  - 为什么分段系统比分页系统更容易实现地址变换？

    （可能一个函数块位于不同的页面中，地址转换需要多次，而分段中，只需要一次即可）

    （从代码共享和信息保护的方向来分析，分段是为一个段进行逻辑共享或者共享，而分页系统的页面大小是固定的，所以某个函数分段可能位于不同的页面中，对代码共享和信息保护没有分段好）

  - 分区分配方案能用于实现虚拟内存吗？（应该是可以的，使用覆盖和交换技术实现内存的扩容）



- PCI总线是什么（Peripheral Component Interconnect 外围设备互连，算是比较大的总线）
- SCSI总线是什么（Small Computer-Systems Interface 小型计算机系统接口，有自己的控制器，常附在磁盘上，磁盘侧面的电路板就是控制器）
- 处理机是如何操作I/O设备的（通过设备控制器，控制器中有数据寄存器和控制寄存器，CPU处理这些寄存器来与I/O进行通信）
- I/O设备控制器中通常有几个寄存器，分别是什么？（4个，设备状态寄存器，设备控制寄存器，数据输入寄存器，数据输出期存器）

- USB是什么？有没有固定的总线I/O地址，没有的话它的地址是如何来的？（Universal Serial Bus 通用串行总线，没有分配固定的总线I/O地址，而是通过软件来虚拟的）



- 简要描述设备控制的几种方式

  - 循环等待（忙等待）：
    - CPU一直询问设备状态寄存器的状态位，直到变成0；
    - 向控制寄存器置写位，并在数据输出寄存器写入一个字节数据；向控制寄存器置命令就绪位；
    - 控制器发现命令就绪位，置状态寄存器为1；读取设备控制器的命令为写命令，就读出输出寄存器内容送设备；
    - 控制器清空命令就绪位和状态寄存器忙位I/O完成
  - 中断方式
    - CPU中有两种中断请求线（一种是可屏蔽的，一种是不可屏蔽的），执行完每条指令后查询中断请求线；
    - CPU发送读请求，设备控制器向寄存器写入数据，写满后向CPU发送中断请求
    - CPU保存中断现场，（中断向量表）送中断向量（内存固定地址执行中断处理程序）
    - 处理中断（设备往寄存器中写入数据，写满了再向CPU发送中断）
    - 恢复中断现场

  - 直接内存访问（DMA Direct Memory Access）
    - 类似中断方式，只不过是指定内存满了之后再向CPU发中断
    - 首先CPU向DMA控制器发送读指令、内存始址和写入字节数
    - DMA控制器抢占内存总线（这时CPU不能再访问内存），开始从设备依次读取数据，计数器依次减小，当减至为零的时候，向CPU发送中断

  - 通道
    - 独立于CPU的专管IO控制的处理机，控制设备与内存直接进行数据交换
    - 通道有自己的指令，有自己的总线控制部分

- 使用什么软件来控制设备控制器（设备驱动软件）









- 涉及算法：进程调度算法，可变分区分配算法，页面置换算法、银行家算法、同步与互斥算法





































